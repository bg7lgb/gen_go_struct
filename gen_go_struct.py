# gen_go_struct.py
# generate golang struct from MySQL tables  
# author: bg7lgb@gmail.com

import sys
import time
import argparse
import pymysql      

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--user', help='db user name')
    parser.add_argument('-s', '--server', help='db server')
    parser.add_argument('-p', '--port', type=int, help='db port')
    parser.add_argument('-d', '--database', required=True, help='database name')
    parser.add_argument('-t', '--table', help='table name')
    parser.add_argument('-j', '--json', action='store_true', help='add json tag')
    # parser.add_argument('-n', '--package_name', help='golang package name')

    args = parser.parse_args()

    user = args.user
    server = args.server
    port = args.port
    database = args.database
    table = args.table
    # package_name = args.package_name

    if user == "" or user is None:
        user = 'root'

    if server == "" or server is None:
        server = 'localhost'
    
    if port is None:
        port = 3306

    # print('user: {0}'.format(user))
    # print('host: {0}'.format(server))
    # print('port: {0}'.format(port))
    # print('database: {0}'.format(database))

#    db_passwd = input('db passwd:')
    db_passwd = 'db2bg7lgb'

    conn = pymysql.connect(host=server, user=user, port=port, 
    passwd=db_passwd,db='information_schema',charset='utf8')

    cu = conn.cursor()

    sql_cols = """select column_name,data_type,is_nullable,column_default,\
    character_maximum_length,numeric_precision,numeric_scale,column_comment \
    from columns where table_schema=%s and table_name=%s"""

    sql_tab_comment = """select table_comment from tables where table_schema=%s and table_name=%s""" 

    sql_tabs = """select table_name,table_comment from tables where table_schema=%s order by table_name"""

    print("package entity")
    print("// generated by gen_go_struct.py")
    print("// author: bg7lgb@gmail.com")
    print("// date: {}".format(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) ))
    print("")
    
    # generate specific table 
    if table != "" and table is not None:
        cu.execute(sql_tab_comment, (database,table,))
        tab_comment = cu.fetchall() 

        cu.execute(sql_cols, (database,table,))
        rows = cu.fetchall()
        cols = gen_struct(table, rows, tab_comment[0][0], args.json)

        for i in range(len(cols)):
            print(cols[i])

    else:
        # generate all tables
        cu.execute(sql_tabs, (database,))
        tabs = cu.fetchall()
        for i in range(len(tabs)):
            cu.execute(sql_cols, (database, tabs[i][0],))
            rows = cu.fetchall()
            cols = gen_struct(tabs[i][0], rows, tabs[i][1], args.json)

            for i in range(len(cols)):
                print(cols[i])
        
            print('\n')

    cu.close()
    conn.close()

def gen_struct(table_name, rows, table_comment, to_json):
    ''' convert resultset(rows) to golang struct '''
    results = []

    # remove '_' in table_name and convert table_name capitalize
    struct_name = ''.join(list(map(lambda x: x.capitalize(), table_name.split('_'))))

    results.append("// {} : table_name: {} comment: {}".format(struct_name, table_name, table_comment) )
    results.append("type " + struct_name + " struct {")
    if len(rows) > 0 :

        for i in range(len(rows)):
            # remove '_' in column name, and convert column name capitalize
            col_name = ''.join(list(map(lambda x: x.capitalize(), rows[i][0].split('_'))))

            # set null_able
            if rows[i][2] == 'YES':
                null_able = True
            else:
                null_able = False

            # set data type
            if rows[i][1] == 'integer':
                if null_able:
                    data_type = 'sql.NullInt64'
                else:
                    data_type = 'int'
            elif rows[i][1] =='bigint' :
                if null_able: 
                    data_type = 'sql.NullInt64'
                else:
                    data_type = 'int64' 
            elif rows[i][1] == 'bool':
                if null_able:
                    data_type = 'sql.NullBool'
                else:
                    data_type = 'bool'
            elif rows[i][1] in ('varchar', 'longtext', 'char'): 
                if null_able:
                    data_type = 'sql.NullString'
                else:
                    data_type = 'string'
            elif rows[i][1] in('date','datetime','timestamp'):
                if null_able:
                    data_type = 'mysql.NullTime'
                else:
                    data_type = 'time.Time'
            elif rows[i][1] == 'tinyint':
                if null_able:
                    data_type = 'sql.NullInt64'
                else:
                    data_type = 'int8'
            elif rows[i][1] == 'smallint':
                if null_able:
                    data_type = 'sql.NullInt64'
                else:
                    data_type = 'int16'
            elif rows[i][1] == 'bigint':
                if null_able:
                    data_type = 'sql.NullInt64'
                else:
                    data_type = 'int64'
            elif rows[i][1] in('decimal', 'double'):
                if null_able:
                    data_type = 'sql.NullFloat64'
                else:
                    data_type = 'float64'
            else: 
                data_type = 'unknown'

            if to_json:
                # col = fmt.Sprintf("%s %s `db:\"%s\" json:\"%s\"`", col_name, data_type, rows[i][0], rows[i][0])
                col = "{} {} `db:\"{}\" json:\"{}\"`".format(col_name, data_type, rows[i][0], rows[i][0])
            else:
                col = "{} {} `db:\"{}\"`".format(col_name, data_type, rows[i][0])
            results.append(col)
        
        results.append("}")
    return results

if __name__ == '__main__':
    main()